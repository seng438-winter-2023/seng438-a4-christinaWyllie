**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#4 â€“ Mutation Testing and Web app testing**

| Group \#:      |  9                 |
| -------------- | ------------------ |
| Student Names: |  Christina Wyllie  |
|                |  Sobia Khan        |
|                |  Maitry Rohit      |
|                |  Jamie Stade       |

# Introduction


# Analysis of 10 Mutants of the Range class 
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

# Report all the statistics and the mutation score for each test class
## Range/DataUtilities Tests
![alt text](https://github.com/seng438-winter-2023/seng438-a4-christinaWyllie/blob/main/Images/PITOverview.png) 

# Analysis drawn on the effectiveness of each of the test classes
Maitry

# A discussion on the effect of equivalent mutants on mutation score accuracy

Tina 
# A discussion of what could have been done to improve the mutation score of the test suites
Sobia

# Why do we need mutation testing? Advantages and disadvantages of mutation testing
Mutation testing is unique because it both verfies the quality of the source code and the test suite itself. By creating mutants, the program can find weak test cases that could be improved on to kill mutants and PITest provides the exact mutants that were tested so that developers know exactly where to check and improve test cases. Additonally, mutation testing improves coverage of the code naturally; the more mutants that are discovered and killed by test cases the more likely it is those test cases increase the coverage of the overall program in a meaningful way. Tests that failed can be analyzed and defects in the source code itself may be found. Logical errors may also be found through mutation testing. 

Unfortunately, mutation testing is very costly and it takes time to produce a massive amount of mutants. For example, the PITtest program had to run for several minutes just to analyze 2 test classes. If a test suite were to be created for the entirety of JFreeChart it would take a significant amount of time to compute mutants. Mutation testing is also hard to understand and use for those unfamiliar with the method and the automated program being used. Extracting information from mutation test results is useful, but it can take a while to learn what the mutation test is attempting to check and how a developer may go about fixing that. Using PITtest was a difficult time consuming process at first. 

# Explain your SELENUIM test case design process
Jamie

# Explain the use of assertions and checkpoints
Tina

# How did you test each functionaity with different test data
Jamie

# Discuss advantages and disadvantages of Selenium vs. Sikulix
Tina 

# How the team work/effort was divided and managed
Every member participated in writing test cases and improving the mutation test score in addition to writing test cases for GUI component of this assignment. Tina, Sobia, and Maitry primarily focused on analyzing mutants while Jamie worked on writing test cases and getting the GUI testing prepared so that other members could later reference that work. The lab document was evenly divided into sections such that each member wrote 2-4 sections based on the complexity of the section. The team met out of lab time to compile lab work and discuss the tests made and how they contributed to the test suite.  

# Difficulties encountered, challenges overcome, and lessons learned
Sobia

# Comments/feedback on the lab itself
The hamcrest library was forgotten in the artifacts given for assignment 4. It would be appreciated if comments were given about how to write sections of the report like in previous assignments.Additionally, it helpful if images were provided for what the program looks like when it's computing mutations. 

